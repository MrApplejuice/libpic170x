Serial library                   {#serial-guide}
==============

[TOC]

The serial library [serial.h](@ref serial.h) provides access to the PIC's UART module and allows it to be used for simple serial communication. Specifically, currently only simple RS232-based 8-bit protocols are supported (e.g. no parity bits, etc). The maximum transmission and receive voltages are given by the used chip types, which means 3.3V for the LF-pic variants and 5V for the F-variants. There is an example illustrating how the library can be used for sending and receiving data in the [examples section](@ref examples-page-serial-echo).

Do not connect your chip to to 12V RS232 directly, it will fry your Microcontroller!


# Initialization

To initialize the serial communication module, you call the serial_init() function to initialize a fresh Serial structure:

~~~~~~~~~~~~~~~~~{.c}
Serial serial;
int real_baudrate = serial_init(&serial, PIN_RA4, PIN_RA5, 9600);

// Check if the baud rate lies withing acceptable paramters
if ((read_baudrate < 9400) || (read_baudrate > 9800)) {
    while (true) {} // Do not continue, fail-state
}
~~~~~~~~~~~~~~~~~

In the example, serial_init() will setup pin RA4 as receive pin and RA5 as transmission pin. Any of the two arguments can be set to NULL to allow transmission or receiving only.

The communication frequency rate on a PIC is derived from the main processor clock (_XTAL_FREQ), and therefore cannot necessarily be configured to exactactly match the required baud rate. The initialization function will attempt to find a prescaler-divider configuration which matches the required baud rate as closely as possible. Since it is likely impossible to derive an exact match, the function will return the actual baud rate as a function result. The caller should check if the returned baud rate falls within an acceptable parameter range and continue accordingly.

**Note**: serial_init() can fail to derive a working prescaler-divider combination altogether, in which case the funtion will return zero. In this case, the UART module will not be initialized at all:

~~~~~~~~~~~~~~~~~{.c}
Serial serial;
int real_baudrate = serial_init(&serial, PIN_RA4, PIN_RA5, 1000000000); // <- baud_rate way too high!
if (!real_baudrate) {
    // PIN_RA4 and PIN_RA5 were not reconfigured here!
    
    while (true) {}
}
~~~~~~~~~~~~~~~~~


# Sending/Receiving

After initializing the module, it is time to read from and write to the serial interface. This is done by directly reading from and writing to receive and send buffers in Serial structure itself. Example of a simple echo program:

~~~~~~~~~~~~~~~~~{.c}
Serial serial;
int real_baudrate = serial_init(&serial, PIN_RA4, PIN_RA5, 9600);
// ...

// Check if we received some characters
if (serial.receive_len > 0) {
    // Shift the send-buffer to the left
    memmove(
        serial.send_queue,
        serial.send_queue + serial.send_index,
        SERIAL_QUEUE_LEN - serial.send_index);
    serial.send_len -= serial.send_index;
    serial.send_index = 0;

    // Safely append receive queue to send-buffer, truncating data
    // if necessary (should never be necessary, actually)
    int bytesToCopy = serial.receive_len;
    if (bytesToCopy > SERIAL_QUEUE_LEN - serial.send_index) {
        bytesToCopy = SERIAL_QUEUE_LEN - serial.send_index;
    }
    memmove(
        serial.send_queue + serial.send_len,
        serial.receive_queue,
        bytesToCopy);
    serial.send_len += bytesToCopy;

    serial.receive_len = 0;
}

~~~~~~~~~~~~~~~~~


## Interrupts

Interrupts are not handled by the library but can be used to handle processing of the library's I/O buffers. To enable interrupts, the typical set of flags need to be enabled:

* RCIE/TXIE to enable interrupts on reception/transmission of bytes
* PEIE to enable interrupts generated by peripherals
* GIE to enable interrupts globally

It can be handy to automate flushing of the I/O buffers through the means of interrupts since it allows for simple implementations of the send logic. Keep in mind though, that sending must be "primed" by calling `serial_handle_queue()` once to push out the first byte. Example:

~~~~~~~~~~~~~~~~~~~~~{.c}

Serial serial;

// Interrupt handler
void interrupt int_handler() {
    if (RCIF || TXIF) {
        // Handle serial interface code. This will clear RCIF and TXIF so both must be checked together!
        serial_handle_queue(&serial);
        
        if (serial.receive_len > 0) {
            // Handle received data...
        }
    }
}

int main() {
    serial_init(&serial, ...);

    // Enable interrupts
    RCIE = 1;
    TXIE = 1;
    PEIE = 1;
    GIE = 1;

    // Fill send buffer
    GIE = 0;
    serial.send_queue[0] = 1;
    serial.send_queue[1] = 2;
    serial.send_queue[2] = 3;
    serial.send_len = 3;
    GIE = 1;

    // Push out first byte. The remaining bytes will be pushed 
    // out by the interrupt handler.
    serial_handle_queue(&serial);

    // ...
}


~~~~~~~~~~~~~~~~~~~~~

# Example